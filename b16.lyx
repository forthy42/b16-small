#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass literate-article
\begin_preamble
\usepackage[dvips,colorlinks=true,linkcolor=blue]{hyperref}
\DeclareGraphicsExtensions{.pdf}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language american
\language_package default
\inputencoding auto
\fontencoding global
\font_roman ae
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 0
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 36pt
\topmargin 1in
\rightmargin 36pt
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 2
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
b16 Documentation
\end_layout

\begin_layout Author

\noun on
Bernd Paysan
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
lhead{
\end_layout

\end_inset

b16 Documentation
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\backslash
chead{
\end_layout

\end_inset


\noun on
Bernd Paysan
\noun default

\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
This article presents architecture and implementation of the b16 stack processor.
 This processor is inspired by 
\noun on
Chuck Moore'
\noun default
s newest Forth processors.
 The minimalistic design fits into small FPGAs and ASICs and is ideally
 suited for applications that need both control and calculations.
 The factor is shifted towards control to save space.
 The synthesizable implementation uses Verilog.
\end_layout

\begin_layout Section*
Introduction
\end_layout

\begin_layout Standard
Minimalistic CPUs can be used in many designs.
 A state machine often is too complicated and too difficult to develop,
 when there are more than a few states.
 A program with subroutines can perform a lot more complex tasks, and is
 easier to develop at the same time.
 Also, ROM and RAM blocks occupy much less place on silicon than 
\begin_inset Quotes eld
\end_inset

random logic
\begin_inset Quotes erd
\end_inset

.
 That's also valid for FPGAs, where 
\begin_inset Quotes eld
\end_inset

block RAM
\begin_inset Quotes erd
\end_inset

 is---in contrast to logic elements---plenty.
\end_layout

\begin_layout Standard
The architecture is inspired by the c18 from
\noun on
 Chuck Moore
\noun default
 
\begin_inset CommandInset citation
LatexCommand cite
key "c18"

\end_inset

.
 The exact instruction mix is different; it also differs from the standard
 b16 core.
 Also, this architecture is byte-addressed.
\end_layout

\begin_layout Standard
A word about Verilog: Verilog is a C-like language, but tailored for the
 purpose to simulate logic, and to write synthesizable code.
 Variables are bits and bit vectors, and assignments are typically non-blocking,
 i.e.
 on assignments first all right sides are computed, and the left sides are
 modified afterwards.
 Also, Verilog has events, like changing of values or clock edges, and blocks
 can wait on them.
\end_layout

\begin_layout Section
Architectural Overview
\end_layout

\begin_layout Standard
The core components are
\end_layout

\begin_layout Itemize
An ALU
\end_layout

\begin_layout Itemize
A data stack with top and next of stack (T and N) as inputs for the ALU
\end_layout

\begin_layout Itemize
A return stack
\end_layout

\begin_layout Itemize
An instruction pointer P 
\end_layout

\begin_layout Itemize
An address mux 
\family typewriter
addr
\family default
, to address external memory
\end_layout

\begin_layout Itemize
An instruction latch I
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "blockdiagram"

\end_inset

 shows a block diagram.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename b16-small.pdf
	width 100col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Block Diagram
\begin_inset CommandInset label
LatexCommand label
name "blockdiagram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Register
\end_layout

\begin_layout Standard
In addition to the standard Forth machine registers there are control registers
 for external RAM (
\family typewriter
rd
\family default
 and 
\family typewriter
wr
\family default
), stack pointers (
\family typewriter
sp
\family default
 and 
\family typewriter
rp
\family default
), and a carry 
\family typewriter
c
\family default
.
 For consistency with Chuck Moores' nomenclature, violating most coding
 style guidelines, the Forth machine registers are single-letter variables
 in upper case.
 Since the source code is a LyX document, you can use the 
\begin_inset Quotes eld
\end_inset

search whole word
\begin_inset Quotes erd
\end_inset

 mode to find them easily, and they also show up on top of the signal list
 during simulation.
\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Function
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Top of Stack
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instruction Bundle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Program Counter
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Top of Returnstack
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
state
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Processor State
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sp
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Stack Pointer
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rp
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Return Stack Pointer
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Carry Flag
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Scrap
<<register declarations>>=
\end_layout

\begin_layout Scrap
reg [sdep-1:0] sp;
\end_layout

\begin_layout Scrap
reg [rdep-1:0] rp;
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
reg `L T, I, P, R;
\end_layout

\begin_layout Scrap
reg [1:0] state;
\end_layout

\begin_layout Scrap
reg c;
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
\begin_inset Float table
wide true
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="10">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Comment
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nop
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
call
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jmp
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ret
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jnz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
jnc
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
exec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
goto
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ret
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
gz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
gnz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
gc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
gnc
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
for slot 3 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
xor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
com
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
and
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
or
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $*+$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $/-$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
!+
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@+
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
lit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c!+
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c@+
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c@
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
litc
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
!.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
lit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c!.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c@.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c@
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
litc
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
for slot 1
\emph default
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
nip
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
drop
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
over
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
dup
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
>r
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
r>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Instruction Set
\begin_inset CommandInset label
LatexCommand label
name "instructions"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Instruction Set
\end_layout

\begin_layout Standard
There are 32 different instructions.
 Since several instructions fit into a 16 bit word, we call the bits to
 store the packed instructions in an instruction word 
\begin_inset Quotes eld
\end_inset

slot
\begin_inset Quotes erd
\end_inset

, and the instruction word itself 
\begin_inset Quotes eld
\end_inset

bundle
\begin_inset Quotes erd
\end_inset

.
 The arrangement here is 1,5,5,5, i.e.
 the first slot is only one bit large (the more significant bits are filled
 with 0), and the others all 5 bits.
\end_layout

\begin_layout Standard
The operations in one instruction word are executed one after the other.
 Each instruction takes one cycle, memory operation (including instruction
 fetch) need another cycle.
 Which instruction is to be executed is stored in the variable 
\family typewriter
state
\family default
.
\end_layout

\begin_layout Standard
The instruction set is divided into four groups: jumps, ALU, memory, and
 stack.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "instructions"

\end_inset

 shows an overview over the instruction set.
 Note: Some special characters indicate functions as follows:
\end_layout

\begin_layout Description
! 
\begin_inset Quotes eld
\end_inset

store
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Description
@ 
\begin_inset Quotes eld
\end_inset

load
\begin_inset Quotes erd
\end_inset

, 
\end_layout

\begin_layout Description
> 
\begin_inset Quotes eld
\end_inset

to
\begin_inset Quotes erd
\end_inset

 if before, 
\begin_inset Quotes eld
\end_inset

from
\begin_inset Quotes erd
\end_inset

 if afterwards.
\end_layout

\begin_layout Standard
Operations will be described using a 
\begin_inset Quotes eld
\end_inset

stack effect
\begin_inset Quotes erd
\end_inset

.
 This is a template for the stack elements before and after the operation,
 separated by a long dash.
 The names are listed in the order bottom to top, unchanged stack elements
 below are not listed.
\end_layout

\begin_layout Standard
Jumps use the rest of the instruction word as target address (except 
\family typewriter
ret
\family default
).
 The lower bits of the instruction pointer P are replaced, there's nothing
 added.
 For instructions in the last slot, no address remains, so they use T (TOS)
 as target.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<instruction selection>>=
\end_layout

\begin_layout Scrap
// instruction and branch target selection   
\end_layout

\begin_layout Scrap
wire [4:0] inst, rwinst;
\end_layout

\begin_layout Scrap
reg `L jmp;
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
assign inst = { 4'b0000, data[15], I[14:0] }
\end_layout

\begin_layout Scrap
              >> (5*(3-state[1:0]));
\end_layout

\begin_layout Scrap
assign rwinst = { 5'b00000, I[14:0] }
\end_layout

\begin_layout Scrap
                >> (5*(3-state[1:0]));
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
always @(state or I or P or T or data)
\end_layout

\begin_layout Scrap
   case(state[1:0])
\end_layout

\begin_layout Scrap
     2'b00: jmp = { data[14:0], 1'b0 };
\end_layout

\begin_layout Scrap
     2'b01: jmp = { P[15:11], I[9:0], 1'b0 };
\end_layout

\begin_layout Scrap
     2'b10: jmp = { P[15:6], I[4:0], 1'b0 };
\end_layout

\begin_layout Scrap
     2'b11: jmp = { T[15:1], 1'b0 };
\end_layout

\begin_layout Scrap
   endcase // casez(state)
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The instructions themselves are executed depending on 
\family typewriter
inst
\family default
:
\end_layout

\begin_layout Scrap
<<instructions>>=
\end_layout

\begin_layout Scrap
case(inst)
\end_layout

\begin_layout Scrap
   <<control flow>>
\end_layout

\begin_layout Scrap
   <<ALU operations>>
\end_layout

\begin_layout Scrap
   <<load/store>>
\end_layout

\begin_layout Scrap
   <<stack operations>>
\end_layout

\begin_layout Scrap
endcase // case(inst)
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
Jumps
\end_layout

\begin_layout Standard
In detail, jumps are performed as follows: the target address is stored
 in the address latch 
\family typewriter
addr
\family default
, which addresses memory, not in the P register.
 The register P will be set to the incremented value of 
\family typewriter
addr
\family default
, after the instruction fetch cycle.
 Apart from 
\family typewriter
call
\family default
, 
\family typewriter
jmp
\family default
 and 
\family typewriter
ret
\family default
 there are conditional jumps, which test for 0 and carry.
 The lowest bit of the return stack is used to save the carry flag across
 calls.
 Conditional instructions don't consume the tested value, which is different
 from Forth.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To make it easier to understand, I also define the effect of an instruction
 in a pseudo language.
 Every instruction has a stack effect (before---after) with top of stack
 on the right, 
\begin_inset Quotes eld
\end_inset

r:
\begin_inset Quotes erd
\end_inset

 prefix indicating return stack, and register assignments:
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
nop ( --- )
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
call ( ---r:P ) 
\begin_inset Formula $\mathrm{P}\leftarrow jmp$
\end_inset

; 
\begin_inset Formula $\mathrm{c}\leftarrow0$
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
jmp ( --- ) 
\begin_inset Formula $\mathrm{P}\leftarrow jmp$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
ret ( r:a--- ) 
\begin_inset Formula $\mathrm{P}\leftarrow a\wedge\$\mathrm{FFFE}$
\end_inset

; 
\begin_inset Formula $\mathrm{c}\leftarrow a\wedge1$
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
jz ( n--- ) 
\begin_inset Formula $\mathbf{if}(n=0)\,\mathrm{P}\leftarrow jmp$
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
jnz ( n--- ) 
\begin_inset Formula $\mathbf{if}(n\ne0)\,\mathrm{P}\leftarrow jmp$
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
jc ( x--- ) 
\begin_inset Formula $\mathbf{if}(c)\,\mathrm{P}\leftarrow jmp$
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
jnc ( x--- ) 
\begin_inset Formula $\mathbf{if}(c=0)\,\mathrm{P}\leftarrow jmp$
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<control flow>>=
\end_layout

\begin_layout Scrap
5'b00001: begin // call
\end_layout

\begin_layout Scrap
   rp <= rpdec;
\end_layout

\begin_layout Scrap
   R <= { ~|state ? incaddr[15:1] : P[15:1], c };
\end_layout

\begin_layout Scrap
   P <= jmp;
\end_layout

\begin_layout Scrap
   c <= 1'b0;
\end_layout

\begin_layout Scrap
   if(state == 2'b11) `DROP;
\end_layout

\begin_layout Scrap
end // case: 5'b00001
\end_layout

\begin_layout Scrap
5'b00010: begin // jmp
\end_layout

\begin_layout Scrap
   P <= jmp;
\end_layout

\begin_layout Scrap
   if(state == 2'b11) `DROP;
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
5'b00011: // ret
\end_layout

\begin_layout Scrap
          { rp, c, P, R } <= 
\end_layout

\begin_layout Scrap
          { rpinc, R[0], R[l-1:1], 1'b0, toR };
\end_layout

\begin_layout Scrap
5'b00100, 5'b00101, 5'b00110, 5'b00111:
\end_layout

\begin_layout Scrap
begin // conditional jmps
\end_layout

\begin_layout Scrap
   if((inst[1] ? c : zero) ^ inst[0]) 
\end_layout

\begin_layout Scrap
      P <= jmp;
\end_layout

\begin_layout Scrap
   `DROP;
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
ALU Operations
\end_layout

\begin_layout Standard
The ALU instructions use the ALU, which computes a result 
\family typewriter
res
\family default
 and a carry bit from T and N.
 The instruction 
\family typewriter
com
\family default
 is an exception, since it only inverts T---that doesn't require an ALU.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ordinary ALU instructions just write the result of the ALU into T and c,
 and reload N.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
xor ( a b---r ) 
\begin_inset Formula $r\leftarrow a\oplus b$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
com ( a---r ) 
\begin_inset Formula $r\leftarrow a\oplus\$\mathrm{FFFF}$
\end_inset

, 
\begin_inset Formula $\mathrm{c}\leftarrow1$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
and ( a b---r ) 
\begin_inset Formula $r\leftarrow a\wedge b$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
or ( a b---r ) 
\begin_inset Formula $r\leftarrow a\vee b$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
+ ( a b---r ) 
\begin_inset Formula $\mathrm{c},r\leftarrow a+b$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
+c ( a b---r ) 
\begin_inset Formula $\mathrm{c},r\leftarrow a+b+\mathrm{c}$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $*$
\end_inset

+ ( a b---a r ) 
\begin_inset Formula $\mathbf{if}(\mathrm{c})\, c_{n},r\leftarrow a+b\,\mathbf{else}\, c_{n},r\leftarrow0,b$
\end_inset

; 
\begin_inset Formula $r,\mathrm{R},\mathrm{c}\leftarrow c_{n},r,\mathrm{R}$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
/-- ( a b---a r ) 
\begin_inset Formula $c_{n},r_{n}\leftarrow a+b+1;$
\end_inset

 
\begin_inset Formula $\mathbf{if}(\mathrm{c}\vee c_{n})\, r\leftarrow r_{n}$
\end_inset

; 
\begin_inset Formula $\mathrm{c},r,\mathrm{R}\leftarrow r,\mathrm{R},\mathrm{c}\vee c_{n}$
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<ALU operations>>=
\end_layout

\begin_layout Scrap
5'b01001: // com
\end_layout

\begin_layout Scrap
   { c, T } <= { 1'b1, ~T };
\end_layout

\begin_layout Scrap
5'b01110: // *+
\end_layout

\begin_layout Scrap
   { T, R, c } <=
\end_layout

\begin_layout Scrap
   { c ? { carry, res } : { 1'b0, T }, R };
\end_layout

\begin_layout Scrap
5'b01111: // /-
\end_layout

\begin_layout Scrap
   { c, T, R } <=
\end_layout

\begin_layout Scrap
   { (c | carry) ? res : T, R, (c | carry) };
\end_layout

\begin_layout Scrap
5'b01000, 5'b01010, 5'b01011, 5'b01100, 5'b01101:
\end_layout

\begin_layout Scrap
   // xor, and, or, +, +c
\end_layout

\begin_layout Scrap
   { sp, c, T } <= { spinc, carry, res };
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
Memory Instructions
\end_layout

\begin_layout Standard
Memory instructions use either T as address, and N as data (source or destinatio
n), or P as address, and T as destination (literals).
 The address is auto-incremented, except for instructions in the first slot
 which use T as address---this is to implement read-modify-write instructions
 (non-incremeting is written as @.
 or !.
 in the assembler, don't care as @* or !*).
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
!+ ( n A---A' ) 
\begin_inset Formula $mem[A]\leftarrow n$
\end_inset

; 
\begin_inset Formula $\mathrm{A'}\leftarrow\mathrm{A}+2$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
@+ ( A---n A' ) 
\begin_inset Formula $n\leftarrow mem[\mathrm{A}]$
\end_inset

; 
\begin_inset Formula $\mathrm{A'}\leftarrow\mathrm{A}+2$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
@ ( A---n ) 
\begin_inset Formula $n\leftarrow mem[\mathrm{A}]$
\end_inset

; 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
lit ( ---n ) 
\begin_inset Formula $n\leftarrow mem[\mathrm{P}]$
\end_inset

; 
\begin_inset Formula $\mathrm{P}\leftarrow\mathrm{P}+2$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
c!+ ( c A---A' ) 
\begin_inset Formula $mem.b[\mathrm{A}]\leftarrow c$
\end_inset

; 
\begin_inset Formula $\mathrm{A'}\leftarrow\mathrm{A}+1$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
c@+ ( A---c A' ) 
\begin_inset Formula $c\leftarrow mem.b[\mathrm{A}]$
\end_inset

; 
\begin_inset Formula $\mathrm{A'}\leftarrow\mathrm{A}+1$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
c@ ( A---c ) 
\begin_inset Formula $c\leftarrow mem.b[\mathrm{A}]$
\end_inset

; 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
litc ( ---c ) 
\begin_inset Formula $c\leftarrow mem.b[\mathrm{P}]$
\end_inset

; 
\begin_inset Formula $\mathrm{P}\leftarrow\mathrm{P}+1$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<address handling>>=
\end_layout

\begin_layout Scrap
wire `L incaddr, dataw, datas;
\end_layout

\begin_layout Scrap
wire tos2n;
\end_layout

\begin_layout Scrap
wire incby, bswap, addrsel, access, rd;
\end_layout

\begin_layout Scrap
wire [1:0] wr;
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
assign incby = (rwinst[4:2] != 3'b101);
\end_layout

\begin_layout Scrap
assign access = (rwinst[4:3]==2'b10);
\end_layout

\begin_layout Scrap
assign addrsel = rd ? 
\end_layout

\begin_layout Scrap
      (access & (rwinst[1:0] != 2'b11)) : |wr;
\end_layout

\begin_layout Scrap
assign rd = (state==2'b00) || 
\end_layout

\begin_layout Scrap
            (access && (rwinst[1:0]!=2'b00));
\end_layout

\begin_layout Scrap
assign wr = (access && (rwinst[1:0]==2'b00)) ?
\end_layout

\begin_layout Scrap
            { ~rwinst[2] | ~T[0], 
\end_layout

\begin_layout Scrap
              ~rwinst[2] | T[0] } : 2'b00;
\end_layout

\begin_layout Scrap
assign addr = addrsel ? T : P;
\end_layout

\begin_layout Scrap
assign incaddr = addr + incby + 1;
\end_layout

\begin_layout Scrap
assign tos2n = (!rd | (rwinst[1:0] == 2'b11));
\end_layout

\begin_layout Scrap
assign toN = tos2n ? T : dataw;
\end_layout

\begin_layout Scrap
assign bswap = ~incby ^ addr[0];
\end_layout

\begin_layout Scrap
assign datas = bswap ? { data[7:0], data[l-1:8] }
\end_layout

\begin_layout Scrap
                     : data;
\end_layout

\begin_layout Scrap
assign dataw = incby ? datas
\end_layout

\begin_layout Scrap
                     : { 8'h00, datas[7:0] }; 
\end_layout

\begin_layout Scrap
assign dataout = bswap ? { N[7:0], N[l-1:8] }
\end_layout

\begin_layout Scrap
                       : N; 
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Memory access can't just be done word wise, but also byte wise.
 Therefore two write lines exist.
 For byte wise store the lower byte of T is copied to the higher one.
\end_layout

\begin_layout Scrap
<<load/store>>=
\end_layout

\begin_layout Scrap
5'b10000, 5'b10001, 5'b10100, 5'b10101:
\end_layout

\begin_layout Scrap
begin        // !+, @+, c!+, c@+
\end_layout

\begin_layout Scrap
   if(nextstate != 2'b10) T <= incaddr;
\end_layout

\begin_layout Scrap
   sp <= rd ? spdec : spinc;
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
5'b10010, 5'b10011, 5'b10110, 5'b10111:
\end_layout

\begin_layout Scrap
   T <= dataw;  // @, lit, c@, litc
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Memory accesses need an extra cycle.
 Here the result of the memory access is handled.
\end_layout

\begin_layout Scrap
<<load-store>>=
\end_layout

\begin_layout Scrap
<<pointer increment>>
\end_layout

\begin_layout Scrap
if(|state[1:0]) begin 
\end_layout

\begin_layout Scrap
   <<store afterwork>>
\end_layout

\begin_layout Scrap
end else begin 
\end_layout

\begin_layout Scrap
   <<ifetch>>
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Scrap
<<debug>>=
\end_layout

\begin_layout Scrap
$write("%b[%b] T=%b%x:%x[%x], ",
\end_layout

\begin_layout Scrap
       inst, state, c, T, N, sp);
\end_layout

\begin_layout Scrap
$write("P=%x, I=%x, R=%x[%x], res=%b%x
\backslash
n",
\end_layout

\begin_layout Scrap
       P, I, R, rp, carry, res);
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
After the access is completed, the result for a load has to be pushed on
 the stack, or into the instruction register; for stores, the TOS is to
 be dropped.
\end_layout

\begin_layout Scrap
<<store afterwork>>=
\end_layout

\begin_layout Scrap
if(rd && { inst[4:3], inst[1:0] } != 4'b1010)
\end_layout

\begin_layout Scrap
   sp <= spdec;
\end_layout

\begin_layout Scrap
if(|wr) sp <= spinc;
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Furthermore, the incremented address may go back to the program pointer.
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
<<pointer increment>>=
\end_layout

\begin_layout Scrap
if(~|state || 
\end_layout

\begin_layout Scrap
   ({ inst[4:3], inst[1:0] } == 4'b1011))
\end_layout

\begin_layout Scrap
   P <= incaddr;
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
To shortcut a 
\family typewriter
nop
\family default
 in the first instruction, there's some special logic.
 That's the second part of NEXT.
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
<<ifetch>>=
\end_layout

\begin_layout Scrap
I <= data; 
\end_layout

\begin_layout Scrap
if(!data[15]) state[1:0] <= 2'b01;
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsubsection
Peripherals
\end_layout

\begin_layout Standard
Peripherals should only use address bits [15:1], read a whole word, and
 select the bytes written to based on the two write bits (bit 1 for most
 significant byte, bit 0 for least significant byte).
\end_layout

\begin_layout Subsection
Stack Instructions
\end_layout

\begin_layout Standard
Stack instructions change the stack pointer and move values into and out
 of latches.
 With the 6 used stack operations, one notes that 
\family typewriter
swap
\family default
 is missing.
 Instead, there's 
\family typewriter
nip
\family default
.
 The reason is a possible implementation option: it's possible to omit N,
 and fetch this value directly out of the stack RAM.
 This consumes more time, but saves space.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
nip ( a b---b )
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
drop ( a--- )
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
over ( a b---a b a )
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
dup ( a---a a )
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
>r ( a---r:a )
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Description
r> ( r:a---a )
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<stack operations>>=
\end_layout

\begin_layout Scrap
5'b11000: sp <= spinc;               // nip
\end_layout

\begin_layout Scrap
5'b11001: `DROP;                     // drop
\end_layout

\begin_layout Scrap
5'b11010: { sp, T } <= { spdec, N }; // over
\end_layout

\begin_layout Scrap
5'b11011: sp <= spdec;               // dup
\end_layout

\begin_layout Scrap
5'b11100: begin                      // >r
\end_layout

\begin_layout Scrap
   R <= T; rp <= rpdec; `DROP;
\end_layout

\begin_layout Scrap
end // case: 5'b11100
\end_layout

\begin_layout Scrap
5'b11110: begin                      // r>
\end_layout

\begin_layout Scrap
   { sp, T, R } <= { spdec, R, toR };
\end_layout

\begin_layout Scrap
   rp <= rpinc;
\end_layout

\begin_layout Scrap
end // case: 5'b11110
\end_layout

\begin_layout Scrap
default ;                            // noop
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Section
The Rest of the Implementation
\end_layout

\begin_layout Standard
First the implementation file(s) with comment and modules.
 You can either have all in one file (
\family typewriter
b16.v
\family default
), or each module in a file with the same name as the module---the defines
 will go to 
\family typewriter
b16-defines.v
\family default
 for central manipulation of the defines.
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
<<header>>=
\end_layout

\begin_layout Scrap
/*
\end_layout

\begin_layout Scrap
 * b16 core: 16 bits, 
\end_layout

\begin_layout Scrap
 * inspired by c18 core from Chuck Moore
\end_layout

\begin_layout Scrap
 * (c) 2002-2011 by Bernd Paysan
\end_layout

\begin_layout Scrap
 * 
\end_layout

\begin_layout Scrap
 * <<gpl-header>>
\end_layout

\begin_layout Scrap
 */
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Scrap
<<defines>>=
\end_layout

\begin_layout Scrap
`define L [l-1:0]
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
`define DROP { sp, T } <= { spinc, N }
\end_layout

\begin_layout Scrap
`define DEBUGGING
\end_layout

\begin_layout Scrap
`define FPGA
\end_layout

\begin_layout Scrap
// `define BUSTRI
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Scrap
<<b16.v>>=
\end_layout

\begin_layout Scrap
<<header>>
\end_layout

\begin_layout Scrap
/*
\end_layout

\begin_layout Scrap
<<inst-comment>>
\end_layout

\begin_layout Scrap
 */
\end_layout

\begin_layout Scrap
<<defines>>
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
<<ALU>>
\end_layout

\begin_layout Scrap
<<Stack>>
\end_layout

\begin_layout Scrap
<<cpu>>
\end_layout

\begin_layout Scrap
<<debugger>>
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Scrap
<<b16-defines.v>>=
\end_layout

\begin_layout Scrap
<<defines>>
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
<<alu.v>>=
\end_layout

\begin_layout Scrap
<<header>>
\end_layout

\begin_layout Scrap
`include "b16-defines.v"
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
<<ALU>>
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Scrap
<<stack.v>>=
\end_layout

\begin_layout Scrap
<<header>>
\end_layout

\begin_layout Scrap
`include "b16-defines.v"
\end_layout

\begin_layout Scrap
<<Stack>>
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Scrap
<<cpu.v>>=
\end_layout

\begin_layout Scrap
<<header>>
\end_layout

\begin_layout Scrap
/*
\end_layout

\begin_layout Scrap
<<inst-comment>>
\end_layout

\begin_layout Scrap
 */
\end_layout

\begin_layout Scrap
`include "b16-defines.v"
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
<<cpu>>
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Scrap
<<debugger.v>>=
\end_layout

\begin_layout Scrap
<<header>>
\end_layout

\begin_layout Scrap
`include "b16-defines.v"
\end_layout

\begin_layout Scrap
<<debugger>>
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Scrap
<<gpl-header>>=
\end_layout

\begin_layout Scrap
This program is free software; you can redistribute it and/or modify
\end_layout

\begin_layout Scrap
it under the terms of the GNU General Public License as published by
\end_layout

\begin_layout Scrap
the Free Software Foundation; version 2 of the License or any later.
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
This program is distributed in the hope that it will be useful,
\end_layout

\begin_layout Scrap
but WITHOUT ANY WARRANTY; without even the implied warranty of
\end_layout

\begin_layout Scrap
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  See the
\end_layout

\begin_layout Scrap
GNU General Public License for more details.
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
This is not the source code of the program, the source code is a LyX
\end_layout

\begin_layout Scrap
literate programming style article.
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Scrap
<<inst-comment>>= 
\end_layout

\begin_layout Scrap
 * Instruction set:
\end_layout

\begin_layout Scrap
 * 1, 5, 5, 5 bits
\end_layout

\begin_layout Scrap
 *     0    1    2    3    4    5    6    7
\end_layout

\begin_layout Scrap
 *  0: nop  call jmp  ret  jz   jnz  jc   jnc
\end_layout

\begin_layout Scrap
 *  /3      exec goto ret  gz   gnz  gc   gnc
\end_layout

\begin_layout Scrap
 *  8: xor  com  and  or   +    +c   *+   /-
\end_layout

\begin_layout Scrap
 * 10: !+   @+   @    lit  c!+  c@+  c@   litc
\end_layout

\begin_layout Scrap
 *  /1 !.
   @.
   @    lit  c!.
  c@.
  c@   litc
\end_layout

\begin_layout Scrap
 * 18: nip  drop over dup  >r        r>
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
Top Level
\end_layout

\begin_layout Standard
The CPU consists of several parts, which are all implemented in the same
 Verilog module.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<cpu>>=
\end_layout

\begin_layout Scrap
module cpu(clk, latclk, run, nreset, addr, rd, wr, data, 
\end_layout

\begin_layout Scrap
           dataout, gwrite
\end_layout

\begin_layout Scrap
`ifdef DEBUGGING,
\end_layout

\begin_layout Scrap
           dr, dw, daddr, din, dout, bp`endif);
\end_layout

\begin_layout Scrap
   <<port declarations>>
\end_layout

\begin_layout Scrap
   <<register declarations>>
\end_layout

\begin_layout Scrap
   <<instruction selection>>
\end_layout

\begin_layout Scrap
   <<ALU instantiation>>
\end_layout

\begin_layout Scrap
   <<address handling>>
\end_layout

\begin_layout Scrap
   <<stack pushs>>
\end_layout

\begin_layout Scrap
   <<stack instantiation>>
\end_layout

\begin_layout Scrap
   <<state changes>>
\end_layout

\begin_layout Scrap
   <<debugging read>>
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
   always @(posedge clk or negedge nreset)
\end_layout

\begin_layout Scrap
      <<register updates>>
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
endmodule // cpu
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
First, Verilog needs port declarations, so that it can know what's input
 and output.
 The parameter are used to configure other word sizes and stack depths.
 The CPU is not fully scalable, e.g.
 the instruction decoder or the byte swap operation for byte access depends
 on 16 bit word size, but those parts of the CPU that are scalable can be
 scaled by changing that parameter---the others need manual intervention.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
<<port declarations>>=
\end_layout

\begin_layout Scrap
parameter rstaddr=16'h3FFE, show=0,
\end_layout

\begin_layout Scrap
          l=16, sdep=4, rdep=4;
\end_layout

\begin_layout Scrap
input clk, latclk, run, nreset, gwrite;
\end_layout

\begin_layout Scrap
output `L addr;
\end_layout

\begin_layout Scrap
output rd;
\end_layout

\begin_layout Scrap
output [1:0] wr;
\end_layout

\begin_layout Scrap
input  `L data;
\end_layout

\begin_layout Scrap
output `L dataout;
\end_layout

\begin_layout Scrap
<<debugging-ports>>
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The ALU is instantiated with the configured width, and the necessary wires
 are declared
\end_layout

\begin_layout Scrap
<<ALU instantiation>>=
\end_layout

\begin_layout Scrap
wire `L res, toN, toR, N;
\end_layout

\begin_layout Scrap
wire carry, zero;
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
alu #(l) alu16(.res(res), .carry(carry),
\end_layout

\begin_layout Scrap
               .zero(zero),
\end_layout

\begin_layout Scrap
               .T(T), .N(N), .c(c),
\end_layout

\begin_layout Scrap
               .inst(inst[2:0]));
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
Since the stacks work in parallel, we have to calculate when a value is
 pushed onto the stack (thus 
\series bold
only
\series default
 if something is stored there).
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<stack pushs>>=
\end_layout

\begin_layout Scrap
reg dpush, rpush;
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
always @(state or inst or rd or run <<dbg senselist>>)
\end_layout

\begin_layout Scrap
  begin
\end_layout

\begin_layout Scrap
     rpush = 1'b0;
\end_layout

\begin_layout Scrap
     dpush = (|state[1:0] & rd) |
\end_layout

\begin_layout Scrap
             (inst[4] && inst[3] && inst[1]);
\end_layout

\begin_layout Scrap
     case(inst)
\end_layout

\begin_layout Scrap
        5'b00001: rpush = |state[1:0] | run;
\end_layout

\begin_layout Scrap
        5'b11100: rpush = 1'b1;
\end_layout

\begin_layout Scrap
        default ;
\end_layout

\begin_layout Scrap
     endcase // case(inst)
\end_layout

\begin_layout Scrap
     <<stack debugging>>
\end_layout

\begin_layout Scrap
  end
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The stacks don't only consist of the two stack modules, but also need an
 incremented and decremented stack pointer.
 The return stack even allows to write the top of return stack even without
 changing the return stack depth.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
<<stack instantiation>>=
\end_layout

\begin_layout Scrap
wire [sdep-1:0] spdec, spinc;
\end_layout

\begin_layout Scrap
wire [rdep-1:0] rpdec, rpinc;
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
stack #(sdep,l) dstack(.clk(latclk),
\end_layout

\begin_layout Scrap
                       .sp(sp),
\end_layout

\begin_layout Scrap
                       .spdec(spdec),
\end_layout

\begin_layout Scrap
                       .push(dpush),
\end_layout

\begin_layout Scrap
                       .in(toN),
\end_layout

\begin_layout Scrap
                       .out(N),
\end_layout

\begin_layout Scrap
                       .gwrite(gwrite));
\end_layout

\begin_layout Scrap
stack #(rdep,l) rstack(.clk(latclk),
\end_layout

\begin_layout Scrap
                       .sp(rp),
\end_layout

\begin_layout Scrap
                       .spdec(rpdec),
\end_layout

\begin_layout Scrap
                       .push(rpush),
\end_layout

\begin_layout Scrap
                       .in(R),
\end_layout

\begin_layout Scrap
                       .out(toR),
\end_layout

\begin_layout Scrap
                       .gwrite(gwrite));
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
assign spdec = sp-{{(sdep-1){1'b0}}, 1'b1};
\end_layout

\begin_layout Scrap
assign spinc = sp+{{(sdep-1){1'b0}}, 1'b1};
\end_layout

\begin_layout Scrap
assign rpdec = rp-{{(rdep-1){1'b0}}, 1'b1};
\end_layout

\begin_layout Scrap
assign rpinc = rp+{{(rdep-1){1'b0}}, 1'b1};
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The basic core is the fully synchronous register update.
 Each register needs a reset value, and depending on the state transition,
 the corresponding assignments have to be coded.
 Most of that is from above, only the instruction fetch and the assignment
 of the next value of 
\family typewriter
incby
\family default
 has to be done.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
<<register updates>>=
\end_layout

\begin_layout Scrap
if(!nreset) begin
\end_layout

\begin_layout Scrap
   <<resets>>
\end_layout

\begin_layout Scrap
end else if(run) begin
\end_layout

\begin_layout Scrap
`ifdef REPORT_VERBOSE
\end_layout

\begin_layout Scrap
   if(show) begin
\end_layout

\begin_layout Scrap
      <<debug>>
\end_layout

\begin_layout Scrap
   end
\end_layout

\begin_layout Scrap
`endif
\end_layout

\begin_layout Scrap
   <<load-store>>
\end_layout

\begin_layout Scrap
   state <= nextstate;
\end_layout

\begin_layout Scrap
   <<instructions>>
\end_layout

\begin_layout Scrap
end else begin // debug
\end_layout

\begin_layout Scrap
   <<debugging>>
\end_layout

\begin_layout Scrap
end // else: !if(nreset)
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
As reset value, we initialize the CPU so that it is about to fetch the next
 instruction from address 0.
 The stacks are all empty, the registers contain all zeros.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
<<resets>>=
\end_layout

\begin_layout Scrap
state <= 2'b11;
\end_layout

\begin_layout Scrap
P <= rstaddr;
\end_layout

\begin_layout Scrap
T <= 16'h0000;
\end_layout

\begin_layout Scrap
I <= 16'h0000;
\end_layout

\begin_layout Scrap
R <= 16'h0000;
\end_layout

\begin_layout Scrap
c <= 1'b0;
\end_layout

\begin_layout Scrap
sp <= 0;
\end_layout

\begin_layout Scrap
rp <= 0;
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The transition to the next state (the NEXT within a bundle) is done separately.
 That's necessary, since the assignments of the other variables are not
 just dependent on the current state, but partially also on the next state
 (e.g.
 when to fetch the next instruction word).
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<state changes>>=
\end_layout

\begin_layout Scrap
wire [1:0] nextstate;
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
assign nextstate = ((~|inst) || (|inst[4:3])) ?
\end_layout

\begin_layout Scrap
                   state[1:0] + 2'b01 : 2'b00;
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
Debugging
\end_layout

\begin_layout Standard
For debugging purposes, all registers are memory read--writable.
 This requires an external bus master attached to the debugging interface.
 The debugging interface is configured with the DEBUGGING flag.
 It's only active when the processor is stopped, so the processor itself
 can't access its own registers.
\end_layout

\begin_layout Standard
The debugging module offers the following registers as address space:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features tabularvalignment="middle">
<column alignment="right" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Address
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
read
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
write
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$FFE0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
stack[sp++]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
push+T
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$FFE2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rstack[rp++]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rpush+R
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$FFE4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
bp
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
bp
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$FFE6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
state+stop
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
state
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$FFE8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
P
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$FFEA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$FFEC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
$FFEE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The stacks and the state register change state when being read, so be careful!
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<debugger>>=
\end_layout

\begin_layout Scrap
`ifdef DEBUGGING
\end_layout

\begin_layout Scrap
module debugger(clk, nreset, run,
\end_layout

\begin_layout Scrap
                addr, data, r, w,
\end_layout

\begin_layout Scrap
                cpu_addr, cpu_r,
\end_layout

\begin_layout Scrap
                drun, dr, dw, bp);
\end_layout

\begin_layout Scrap
parameter l=16, dbgaddr = 12'hFFE;
\end_layout

\begin_layout Scrap
input clk, nreset, run, r, cpu_r;
\end_layout

\begin_layout Scrap
input [1:0] w;
\end_layout

\begin_layout Scrap
input [l-1:1] addr;
\end_layout

\begin_layout Scrap
input `L data, cpu_addr;
\end_layout

\begin_layout Scrap
output drun, dr, dw;
\end_layout

\begin_layout Scrap
output `L bp;
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
reg drun, drun1;
\end_layout

\begin_layout Scrap
reg `L bp;
\end_layout

\begin_layout Scrap
wire dsel = (addr[l-1:4] == dbgaddr);
\end_layout

\begin_layout Scrap
assign dr = dsel & r;
\end_layout

\begin_layout Scrap
assign dw = dsel & |w;
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
always @(posedge clk or negedge nreset)
\end_layout

\begin_layout Scrap
if(!nreset) begin
\end_layout

\begin_layout Scrap
   drun <= 1;
\end_layout

\begin_layout Scrap
   drun1 <= 1;
\end_layout

\begin_layout Scrap
   bp <= 16'hffff;
\end_layout

\begin_layout Scrap
end else begin
\end_layout

\begin_layout Scrap
   if(cpu_addr == bp && cpu_r)
\end_layout

\begin_layout Scrap
      { drun, drun1 } <= 0;
\end_layout

\begin_layout Scrap
   else if(run) drun <= drun1;
\end_layout

\begin_layout Scrap
   if((dr | dw) && (addr[3:1] == 3'h3)) begin
\end_layout

\begin_layout Scrap
      drun <= !dr & dw;
\end_layout

\begin_layout Scrap
      drun1 <= !dr & dw & data[12];
\end_layout

\begin_layout Scrap
   end
\end_layout

\begin_layout Scrap
   if(dw && addr[3:1] == 3'h2) bp <= data;
\end_layout

\begin_layout Scrap
end
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
endmodule
\end_layout

\begin_layout Scrap
`endif
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Scrap
<<debugging>>=
\end_layout

\begin_layout Scrap
`ifdef DEBUGGING
\end_layout

\begin_layout Scrap
if(dw) case(daddr)
\end_layout

\begin_layout Scrap
   3'h0: { sp, T } <= { spdec, din };
\end_layout

\begin_layout Scrap
   3'h1: { rp, R } <= { rpdec, din };
\end_layout

\begin_layout Scrap
   3'h3: { c, state, sp, rp } <= 
\end_layout

\begin_layout Scrap
           { din[10:8],
\end_layout

\begin_layout Scrap
             din[sdep+3:4], din[rdep-1:0] };
\end_layout

\begin_layout Scrap
   3'h4: P <= din;
\end_layout

\begin_layout Scrap
   3'h5: T <= din;
\end_layout

\begin_layout Scrap
   3'h6: R <= din;
\end_layout

\begin_layout Scrap
   3'h7: I <= din;
\end_layout

\begin_layout Scrap
   default ;
\end_layout

\begin_layout Scrap
endcase
\end_layout

\begin_layout Scrap
if(dr) case(daddr)
\end_layout

\begin_layout Scrap
   3'h0: sp <= spinc;
\end_layout

\begin_layout Scrap
   3'h1: rp <= rpinc;
\end_layout

\begin_layout Scrap
   default ;
\end_layout

\begin_layout Scrap
endcase
\end_layout

\begin_layout Scrap
`endif
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Scrap
<<debugging read>>=
\end_layout

\begin_layout Scrap
`ifdef DEBUGGING
\end_layout

\begin_layout Scrap
reg `L dout;
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
always @(daddr or dr or run or P or T or R or I or
\end_layout

\begin_layout Scrap
         state or sp or rp or c or N or toR or bp)
\end_layout

\begin_layout Scrap
if(!dr || run) dout = 'h0;
\end_layout

\begin_layout Scrap
else case(daddr)
\end_layout

\begin_layout Scrap
   3'h0: dout = N;
\end_layout

\begin_layout Scrap
   3'h1: dout = toR;
\end_layout

\begin_layout Scrap
   3'h2: dout = bp;
\end_layout

\begin_layout Scrap
   3'h3: dout = { run, 4'h0, c, state,
\end_layout

\begin_layout Scrap
                  {4-sdep{1'b0}}, sp,
\end_layout

\begin_layout Scrap
                  {4-rdep{1'b0}}, rp };
\end_layout

\begin_layout Scrap
   3'h4: dout = P;
\end_layout

\begin_layout Scrap
   3'h5: dout = T;
\end_layout

\begin_layout Scrap
   3'h6: dout = R;
\end_layout

\begin_layout Scrap
   3'h7: dout = I;
\end_layout

\begin_layout Scrap
endcase
\end_layout

\begin_layout Scrap
`endif
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Scrap
<<debugging-ports>>=
\end_layout

\begin_layout Scrap
`ifdef DEBUGGING
\end_layout

\begin_layout Scrap
   input [2:0] daddr;
\end_layout

\begin_layout Scrap
   input dr, dw;
\end_layout

\begin_layout Scrap
   input `L din, bp;
\end_layout

\begin_layout Scrap
   output `L dout;
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
`endif
\begin_inset Newline newline
\end_inset

@
\end_layout

\begin_layout Scrap
<<dbg senselist>>=
\end_layout

\begin_layout Scrap
`ifdef DEBUGGING
\end_layout

\begin_layout Scrap
or run or dw or daddr
\end_layout

\begin_layout Scrap
`endif
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Scrap
<<stack debugging>>=
\end_layout

\begin_layout Scrap
`ifdef DEBUGGING
\end_layout

\begin_layout Scrap
if(!run && dw) case(daddr)
\end_layout

\begin_layout Scrap
   3'h0: dpush = 1;
\end_layout

\begin_layout Scrap
   3'h1: rpush = 1;
\end_layout

\begin_layout Scrap
   default ;
\end_layout

\begin_layout Scrap
endcase
\end_layout

\begin_layout Scrap
`endif
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
ALU
\end_layout

\begin_layout Standard
The ALU just computes the sum with possible carry-ins, the logical operations,
 and a zero flag.
 It reuses the same logic (essentially what comprises a full adder) to do
 both sums and logic.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:ALU-bit-slice"

\end_inset

 illustrates the logic that processes one bit of the ALU operation: Two
 multiplexers and one full adder (or the equivalent logic) per bit is sufficient
 to implement an ALU.
 The carry works as an AND gate if the carry in is 0 (both 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 input must be 1 to create a carry out), an OR gate if the carry in is 1
 (both 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 input must be 0 to not create a carry out), and the sum is an XOR of 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 without carry in, and an XNOR with carry in.
 The XNOR operation of the ALU is not used.
 When the carry is propagated, a normal sum is generated; in this case,
 the result 
\begin_inset Formula $r$
\end_inset

 selected is always the sum.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename alu.pdf
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:ALU-bit-slice"

\end_inset

ALU bit slice
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<ALU>>=
\end_layout

\begin_layout Scrap
module alu(res, carry, zero, T, N, c, inst);
\end_layout

\begin_layout Scrap
   <<ALU ports>>
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
   wire        `L r1, r2;
\end_layout

\begin_layout Scrap
   wire [l:0]  carries;
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
   assign r1 = T ^ N ^ carries;
\end_layout

\begin_layout Scrap
   assign r2 = (T & N) | 
\end_layout

\begin_layout Scrap
               (T & carries`L) | 
\end_layout

\begin_layout Scrap
               (N & carries`L);
\end_layout

\begin_layout Scrap
// This generates a carry *chain*, not a loop!
\end_layout

\begin_layout Scrap
   assign carries = 
\end_layout

\begin_layout Scrap
        prop ? { r2[l-1:0], (c | selr) & andor } 
\end_layout

\begin_layout Scrap
             : { c, {(l){andor}}};
\end_layout

\begin_layout Scrap
   assign res = (selr & ~prop) ? r2 : r1;
\end_layout

\begin_layout Scrap
   assign carry = carries[l];
\end_layout

\begin_layout Scrap
   assign zero = ~|T;
\end_layout

\begin_layout Scrap
endmodule // alu
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Standard
The ALU has ports T and N, carry in, and the lowest 3 bits of the instruction
 as input, a result, carry out, and test for zero as output.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
<<ALU ports>>=
\end_layout

\begin_layout Scrap
parameter l=16;
\end_layout

\begin_layout Scrap
input `L T, N;
\end_layout

\begin_layout Scrap
input c;
\end_layout

\begin_layout Scrap
input [2:0] inst;
\end_layout

\begin_layout Scrap
output `L res;
\end_layout

\begin_layout Scrap
output carry, zero;
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
wire prop, andor, selr;
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
assign { prop, selr, andor } = inst;
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Subsection
Stacks
\end_layout

\begin_layout Standard
The stacks are modelled as block RAM in the FPGA.
 In an ASIC, this is implemented with latches.
 The block RAM (or register file) needs one read and one write port.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
filbreak
\end_layout

\end_inset


\end_layout

\begin_layout Scrap
<<Stack>>=
\end_layout

\begin_layout Scrap
module stack(clk, sp, spdec, push, gwrite, in, out);
\end_layout

\begin_layout Scrap
   parameter dep=2, l=16;
\end_layout

\begin_layout Scrap
   input clk, push, gwrite;
\end_layout

\begin_layout Scrap
   input [dep-1:0] sp, spdec;
\end_layout

\begin_layout Scrap
   input `L in;
\end_layout

\begin_layout Scrap
   output `L out;
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
   reg `L stackmem[0:(1@<<dep)-1];
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
`ifndef FPGA
\end_layout

\begin_layout Scrap
   reg [dep:0] i;
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
   always @(clk or push or gwrite or spdec or in)
\end_layout

\begin_layout Scrap
      if(~clk)
\end_layout

\begin_layout Scrap
         if(gwrite)
\end_layout

\begin_layout Scrap
            for(i=0; i<(1@<<dep); i=i+1)
\end_layout

\begin_layout Scrap
               stackmem[i] <= in;
\end_layout

\begin_layout Scrap
         else if(push) stackmem[spdec] <= in;
\end_layout

\begin_layout Scrap
`else
\end_layout

\begin_layout Scrap
   always @(posedge clk)
\end_layout

\begin_layout Scrap
      if(push)
\end_layout

\begin_layout Scrap
         stackmem[spdec] <= in;
\end_layout

\begin_layout Scrap
`endif
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
  assign out = stackmem[sp];
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Scrap
endmodule // stack
\end_layout

\begin_layout Scrap
@
\end_layout

\begin_layout Scrap

\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "c18"

\end_inset


\emph on
c18 ColorForth Compiler,
\emph default
 
\noun on
Chuck Moore
\noun default
, 
\begin_inset Formula $17^{\mathrm{th}}$
\end_inset

 EuroForth Conference Proceedings, 2001
\end_layout

\end_body
\end_document
